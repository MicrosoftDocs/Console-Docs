---
title: High-Level Console Input and Output Functions
description: The ReadFile and WriteFile functions, or the ReadConsole and WriteConsole functions, enable an application to read console input and write console output as a stream of characters.
author: miniksa
ms.author: miniksa
ms.topic: conceptual
keywords: console, character mode applications, command line applications, terminal applications, console api
MS-HAID:
- '\_win32\_high\_level\_console\_input\_and\_output\_functions'
- 'base.high\_level\_console\_input\_and\_output\_functions'
- 'consoles.high\_level\_console\_input\_and\_output\_functions'
MSHAttr:
- 'PreferredSiteName:MSDN'
- 'PreferredLib:/library/windows/desktop'
ms.assetid: 086b1bec-85f8-4e31-848d-7cb2d2703a3d
---

# High-Level Console Input and Output Functions

The [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile) and [**WriteFile**](/windows/win32/api/fileapi/nf-fileapi-writefile) functions, or the [**ReadConsole**](readconsole.md) and [**WriteConsole**](writeconsole.md) functions, enable an application to read console input and write console output as a stream of characters. **ReadConsole** and **WriteConsole** behave exactly like **ReadFile** and **WriteFile** except that they can be used either as wide-character functions (in which text arguments must use Unicode) or as ANSI functions (in which text arguments must use characters from the Windows character set). Applications that need to maintain a single set of sources to support either Unicode or the ANSI character set should use **ReadConsole** and **WriteConsole**.

[**ReadConsole**](readconsole.md) and [**WriteConsole**](writeconsole.md) can only be used with console handles; [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile) and [**WriteFile**](/windows/win32/api/fileapi/nf-fileapi-writefile) can be used with other handles (such as files or pipes). **ReadConsole** and **WriteConsole** fail if used with a standard handle that has been redirected and is no longer a console handle.

To get keyboard input, a process can use [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile) or [**ReadConsole**](readconsole.md) with a handle to the console's input buffer, or it can use **ReadFile** to read input from a file or a pipe if `STDIN` has been redirected. These functions only return keyboard events that can be translated into ANSI or Unicode characters. The input that can be returned includes control key combinations. The functions do not return keyboard events involving the function keys or arrow keys. Input events generated by mouse, window, focus, or menu input are discarded.

If line input mode is enabled (the default mode), [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile) and [**ReadConsole**](readconsole.md) do not return to the calling application until the ENTER key is pressed. If line input mode is disabled, the functions do not return until at least one character is available. In either mode, all available characters are read until either no more keys are available or the specified number of characters has been read. Unread characters are buffered until the next read operation. The functions report the total number of characters actually read. If echo input mode is enabled, characters read by these functions are written to the active screen buffer at the current cursor position.

A process can use [**WriteFile**](/windows/win32/api/fileapi/nf-fileapi-writefile) or **WriteConsole** to write to either an active or inactive screen buffer, or it can use **WriteFile** to write to a file or a pipe if STDOUT has been redirected. Processed output mode and wrap at EOL output mode control the way characters are written or echoed to a screen buffer.

Characters written by [**WriteFile**](/windows/win32/api/fileapi/nf-fileapi-writefile) or [**WriteConsole**](writeconsole.md), or echoed by [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile) or [**ReadConsole**](readconsole.md), are inserted in a screen buffer at the current cursor position. As each character is written, the cursor position advances to the next character cell; however, the behavior at the end of a row depends on the console screen buffer's wrap at EOL output mode.

Further detail about the position of the cursor can be found through **[virtual terminals sequences](console-virtual-terminal-sequences.md)**, specifically in the **[query state](console-virtual-terminal-sequences.md#query-state)** category for finding the current position and the **[cursor positioning](console-virtual-terminal-sequences.md#cursor-positioning)** category for setting the current position. Alternatively, an application can use the [**GetConsoleScreenBufferInfo**](getconsolescreenbufferinfo.md) function to determine the current cursor position and the [**SetConsoleCursorPosition**](setconsolecursorposition.md) function to set the cursor position. However, the **virtual terminal sequences** mechanism is preferred for all new and ongoing development. More details on the strategy behind this decision can be found in the **[classic functions versus virtual terminal](classic-vs-vt.md)** and **[ecosystem roadmap](ecosystem-roadmap.md)** documentation.

For an example that uses the high-level console I/O functions, see [Using the High-Level Input and Output Functions](using-the-high-level-input-and-output-functions.md).